;
; File generated by cc65 v 2.19 - Git 1406346
;
	.fopt		compiler,"cc65 v 2.19 - Git 1406346"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_col
	.import		_pal_clear
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_spr
	.import		_oam_get
	.import		_pad_poll
	.import		_vram_adr
	.import		_vram_put
	.export		_mmc1_write
	.export		_mmc1_init
	.export		_setup_pattern_tables
	.export		_fade_in_palette
	.export		_fade_out_palette
	.export		_create_sprite
	.export		_update_sprite_pos
	.export		_current_bank
	.export		_show_bottom_half
	.export		_current_palette
	.export		_str_bank
	.export		_str_pt
	.export		_str_pal
	.export		_palettes
	.export		_draw_text
	.export		_draw_number
	.export		_draw_border_and_text
	.export		_draw_tile_grid
	.export		_main

.segment	"DATA"

_current_bank:
	.byte	$00
_show_bottom_half:
	.byte	$00
_current_palette:
	.byte	$00

.segment	"RODATA"

_str_bank:
	.byte	$42,$41,$4E,$4B,$3A,$00
_str_pt:
	.byte	$50,$54,$3A,$00
_str_pal:
	.byte	$50,$41,$4C,$3A,$00
_palettes:
	.byte	$0F
	.byte	$00
	.byte	$10
	.byte	$30
	.byte	$0F
	.byte	$06
	.byte	$16
	.byte	$26
	.byte	$0F
	.byte	$09
	.byte	$19
	.byte	$29
	.byte	$0F
	.byte	$01
	.byte	$11
	.byte	$21
	.byte	$0F
	.byte	$08
	.byte	$18
	.byte	$28
	.byte	$0F
	.byte	$0A
	.byte	$1A
	.byte	$2A
	.byte	$0F
	.byte	$07
	.byte	$17
	.byte	$27
	.byte	$0F
	.byte	$02
	.byte	$12
	.byte	$22
	.byte	$0F
	.byte	$05
	.byte	$15
	.byte	$25
	.byte	$0F
	.byte	$03
	.byte	$13
	.byte	$23

; ---------------------------------------------------------------
; void __near__ mmc1_write (unsigned int address, unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_mmc1_write: near

.segment	"CODE"

;
; void mmc1_write(unsigned int address, unsigned char value) {
;
	jsr     pusha
;
; for (i = 0; i < 5; ++i) {
;
	jsr     decsp1
	lda     #$00
	tay
L0006:	sta     (sp),y
	cmp     #$05
	bcs     L0003
;
; *((unsigned char*)address) = value & 1;
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (sp),y
	and     #$01
	dey
	sta     (ptr1),y
;
; value = value >> 1;
;
	iny
	lda     (sp),y
	lsr     a
	sta     (sp),y
;
; for (i = 0; i < 5; ++i) {
;
	dey
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0006
;
; }
;
L0003:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ mmc1_init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_mmc1_init: near

.segment	"CODE"

;
; *((unsigned char*)MMC1_CONTROL) = 0x80;
;
	lda     #$80
	sta     $8000
;
; mmc1_write(MMC1_CONTROL, 0x0C);  // Changed from 0x0E to 0x0C for 4KB CHR mode
;
	tax
	lda     #$00
	jsr     pushax
	lda     #$0C
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR0, CHR_BANK_FONT * 2);      // Pattern table 0: Font (4KB)
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, CHR_BANK_FONT * 2 + 1);  // Pattern table 0: Font (4KB)
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	lda     #$01
	jmp     _mmc1_write

.endproc

; ---------------------------------------------------------------
; void __near__ setup_pattern_tables (unsigned char bg_bank, unsigned char spr_bank)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setup_pattern_tables: near

.segment	"CODE"

;
; void setup_pattern_tables(unsigned char bg_bank, unsigned char spr_bank) {
;
	jsr     pusha
;
; mmc1_write(MMC1_CHR0, bg_bank * 2);      // First 4KB
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	ldy     #$03
	lda     (sp),y
	asl     a
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, bg_bank * 2 + 1);  // Second 4KB
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	ldy     #$03
	lda     (sp),y
	asl     a
	clc
	adc     #$01
	jsr     _mmc1_write
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ fade_in_palette (const unsigned char *palette, unsigned char delay_frames)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_in_palette: near

.segment	"CODE"

;
; void fade_in_palette(const unsigned char *palette, unsigned char delay_frames) {
;
	jsr     pusha
;
; pal_clear();
;
	ldy     #$21
	jsr     subysp
	jsr     _pal_clear
;
; for (i = 0; i < 32; i++) {
;
	lda     #$00
	ldy     #$20
L000F:	sta     (sp),y
	cmp     #$20
	bcs     L0003
;
; temp_pal[i] = palette[i];
;
	lda     sp
	ldx     sp+1
	clc
	adc     (sp),y
	bcc     L0006
	inx
L0006:	sta     sreg
	stx     sreg+1
	ldy     #$23
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$20
	lda     (sp),y
	tay
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; pal_col(i, temp_pal[i]);
;
	ldy     #$20
	lda     (sp),y
	jsr     pusha
	lda     sp
	ldx     sp+1
	clc
	adc     #$01
	bcc     L0007
	inx
L0007:	ldy     #$21
	clc
	adc     (sp),y
	bcc     L0008
	inx
L0008:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jsr     _pal_col
;
; ppu_wait_nmi(); // Wait for NMI to complete
;
	jsr     _ppu_wait_nmi
;
; if (delay_frames > 0) {
;
	ldy     #$21
	lda     (sp),y
	beq     L0004
;
; for (j = 0; j < delay_frames; j++) {
;
	jsr     decsp1
	lda     #$00
	tay
L000E:	sta     (sp),y
	ldy     #$22
	cmp     (sp),y
	bcs     L000B
;
; ppu_wait_nmi(); // Wait for NMI to complete
;
	jsr     _ppu_wait_nmi
;
; for (j = 0; j < delay_frames; j++) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L000E
;
; }
;
L000B:	jsr     incsp1
;
; for (i = 0; i < 32; i++) {
;
L0004:	ldy     #$20
	clc
	lda     #$01
	adc     (sp),y
	jmp     L000F
;
; }
;
L0003:	ldy     #$24
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; void __near__ fade_out_palette (unsigned char delay_frames)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_out_palette: near

.segment	"CODE"

;
; void fade_out_palette(unsigned char delay_frames) {
;
	jsr     pusha
;
; for (i = 0; i < 32; i++) {
;
	ldy     #$22
	jsr     subysp
	lda     #$00
	ldy     #$21
L0019:	sta     (sp),y
	cmp     #$20
	bcs     L001D
;
; temp_pal[i] = 0x0F; // Default to black
;
	lda     sp+1
	sta     ptr1+1
	lda     sp
	sta     ptr1
	lda     (sp),y
	tay
	lda     #$0F
	sta     (ptr1),y
;
; for (i = 0; i < 32; i++) {
;
	ldy     #$21
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0019
;
; for (i = 0; i < 32; i++) {
;
L001D:	lda     #$00
L001C:	sta     (sp),y
	cmp     #$20
	jcs     L0008
;
; for (j = 0; j < 32; j++) {
;
	lda     #$00
	dey
L001A:	sta     (sp),y
	cmp     #$20
	bcs     L000C
;
; if (temp_pal[j] > 0) {
;
	lda     sp
	ldx     sp+1
	clc
	adc     (sp),y
	bcc     L0010
	inx
L0010:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L000D
;
; temp_pal[j]--;
;
	lda     sp
	ldx     sp+1
	ldy     #$20
	clc
	adc     (sp),y
	bcc     L0011
	inx
L0011:	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (sreg),y
;
; pal_col(j, temp_pal[j]);
;
	ldy     #$20
	lda     (sp),y
	jsr     pusha
	lda     sp
	ldx     sp+1
	clc
	adc     #$01
	bcc     L0012
	inx
L0012:	ldy     #$21
	clc
	adc     (sp),y
	bcc     L0013
	inx
L0013:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jsr     _pal_col
;
; for (j = 0; j < 32; j++) {
;
L000D:	ldy     #$20
	clc
	lda     #$01
	adc     (sp),y
	jmp     L001A
;
; ppu_wait_nmi(); // Wait for NMI to complete
;
L000C:	jsr     _ppu_wait_nmi
;
; if (delay_frames > 0) {
;
	ldy     #$22
	lda     (sp),y
	beq     L0009
;
; for (k = 0; k < delay_frames; k++) {
;
	jsr     decsp1
	lda     #$00
	tay
L001B:	sta     (sp),y
	ldy     #$23
	cmp     (sp),y
	bcs     L0016
;
; ppu_wait_nmi(); // Wait for NMI to complete
;
	jsr     _ppu_wait_nmi
;
; for (k = 0; k < delay_frames; k++) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L001B
;
; }
;
L0016:	jsr     incsp1
;
; for (i = 0; i < 32; i++) {
;
L0009:	ldy     #$21
	clc
	lda     #$01
	adc     (sp),y
	jmp     L001C
;
; }
;
L0008:	ldy     #$23
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ create_sprite (unsigned char x, unsigned char y, unsigned char tile, unsigned char palette, unsigned char flip_h, unsigned char flip_v, unsigned char behind)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_create_sprite: near

.segment	"CODE"

;
; unsigned char flip_v, unsigned char behind) {
;
	jsr     pusha
;
; unsigned char attr = palette;
;
	ldy     #$03
	lda     (sp),y
	jsr     pusha
;
; if (flip_h) attr |= OAM_FLIP_H;
;
	ldy     #$03
	lda     (sp),y
	beq     L0002
	ldy     #$00
	lda     (sp),y
	ora     #$40
	sta     (sp),y
;
; if (flip_v) attr |= OAM_FLIP_V;
;
L0002:	ldy     #$02
	lda     (sp),y
	beq     L0003
	ldy     #$00
	lda     (sp),y
	ora     #$80
	sta     (sp),y
;
; if (behind) attr |= OAM_BEHIND;
;
L0003:	ldy     #$01
	lda     (sp),y
	beq     L0004
	dey
	lda     (sp),y
	ora     #$20
	sta     (sp),y
;
; oam_spr(x, y, tile, attr);
;
L0004:	jsr     decsp3
	ldy     #$0A
	lda     (sp),y
	ldy     #$02
	sta     (sp),y
	ldy     #$09
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	ldy     #$08
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$03
	lda     (sp),y
	jsr     _oam_spr
;
; return oam_get();
;
	jsr     _oam_get
;
; }
;
	jmp     incsp8

.endproc

; ---------------------------------------------------------------
; void __near__ update_sprite_pos (unsigned char index, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_sprite_pos: near

.segment	"CODE"

;
; void update_sprite_pos(unsigned char index, unsigned char x, unsigned char y) {
;
	jsr     pusha
;
; oam_spr(x, y, 0, 0); // Use default attributes
;
	jsr     decsp3
	ldy     #$04
	lda     (sp),y
	ldy     #$02
	sta     (sp),y
	iny
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	lda     #$00
	dey
	sta     (sp),y
	jsr     _oam_spr
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ draw_text (const unsigned char *str, unsigned char len)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_text: near

.segment	"CODE"

;
; void draw_text(const unsigned char* str, unsigned char len) {
;
	jsr     pusha
;
; for(i = 0; i < len; ++i) {
;
	jsr     decsp1
	lda     #$00
	tay
L0007:	sta     (sp),y
	iny
	cmp     (sp),y
	bcs     L0003
;
; vram_put(str[i] - 0x20);
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (sp),y
	tay
	lda     (ptr1),y
	sec
	sbc     #$20
	jsr     _vram_put
;
; for(i = 0; i < len; ++i) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0007
;
; }
;
L0003:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ draw_number (unsigned char num)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_number: near

.segment	"CODE"

;
; void draw_number(unsigned char num) {
;
	jsr     pusha
;
; vram_put('0' + num - 0x20);
;
	ldy     #$00
	lda     (sp),y
	clc
	adc     #$30
	sec
	sbc     #$20
	jsr     _vram_put
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ draw_border_and_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_border_and_text: near

.segment	"CODE"

;
; mmc1_write(MMC1_CHR0, 0);
;
	jsr     decsp2
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, 0);  // Keep both banks on font
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; vram_adr(NTADR_A(1,3));
;
	ldx     #$20
	lda     #$61
	jsr     _vram_adr
;
; for(col = 0; col < 18; ++col) vram_put(0x00);
;
	lda     #$00
	tay
L0010:	sta     (sp),y
	cmp     #$12
	bcs     L0013
	tya
	jsr     _vram_put
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0010
;
; for(row = 0; row < 16; ++row) {
;
L0013:	tya
	iny
L0011:	sta     (sp),y
	cmp     #$10
	bcs     L0007
;
; vram_adr(NTADR_A(1, row + 4));
;
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$04
	bcc     L000A
	inx
L000A:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$01
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; vram_adr(NTADR_A(18, row + 4));
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$04
	bcc     L000B
	inx
L000B:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$12
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; for(row = 0; row < 16; ++row) {
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L0011
;
; vram_adr(NTADR_A(1,20));
;
L0007:	ldx     #$22
	lda     #$81
	jsr     _vram_adr
;
; for(col = 0; col < 18; ++col) vram_put(0x00);
;
	lda     #$00
	tay
L0012:	sta     (sp),y
	cmp     #$12
	bcs     L000D
	tya
	jsr     _vram_put
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0012
;
; vram_adr(NTADR_A(2,2));
;
L000D:	ldx     #$20
	lda     #$42
	jsr     _vram_adr
;
; draw_text(str_bank, 5);
;
	lda     #<(_str_bank)
	ldx     #>(_str_bank)
	jsr     pushax
	lda     #$05
	jsr     _draw_text
;
; draw_number(current_bank);
;
	lda     _current_bank
	jsr     _draw_number
;
; vram_adr(NTADR_A(18,2));
;
	ldx     #$20
	lda     #$52
	jsr     _vram_adr
;
; draw_text(str_pal, 4);
;
	lda     #<(_str_pal)
	ldx     #>(_str_pal)
	jsr     pushax
	lda     #$04
	jsr     _draw_text
;
; draw_number(current_palette);
;
	lda     _current_palette
	jsr     _draw_number
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ draw_tile_grid (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_tile_grid: near

.segment	"CODE"

;
; unsigned char tile_offset = show_bottom_half ? 128 : 0;  // Start at 128 for bottom half
;
	jsr     decsp2
	lda     _show_bottom_half
	beq     L0014
	lda     #$80
L0014:	jsr     pusha
;
; pal_col(0, palettes[current_palette * 4 + 0]);
;
	lda     #$00
	jsr     pusha
	tax
	lda     _current_palette
	jsr     shlax2
	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; pal_col(1, palettes[current_palette * 4 + 1]);
;
	lda     #$01
	jsr     pusha
	ldx     #$00
	lda     _current_palette
	jsr     shlax2
	clc
	adc     #$01
	bcc     L0004
	inx
L0004:	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; pal_col(2, palettes[current_palette * 4 + 2]);
;
	lda     #$02
	jsr     pusha
	ldx     #$00
	lda     _current_palette
	jsr     shlax2
	clc
	adc     #$02
	bcc     L0005
	inx
L0005:	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; pal_col(3, palettes[current_palette * 4 + 3]);
;
	lda     #$03
	jsr     pusha
	ldx     #$00
	lda     _current_palette
	jsr     shlax2
	clc
	adc     #$03
	bcc     L0006
	inx
L0006:	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; ppu_off();
;
	jsr     _ppu_off
;
; mmc1_write(MMC1_CHR0, BANK0_TOP);
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, BANK0_TOP);
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; draw_border_and_text();
;
	jsr     _draw_border_and_text
;
; mmc1_write(MMC1_CHR0, current_bank);
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	lda     _current_bank
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, current_bank);
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	lda     _current_bank
	jsr     _mmc1_write
;
; for (row = 0; row < 16; ++row) {
;
	lda     #$00
	ldy     #$02
L0013:	sta     (sp),y
	cmp     #$10
	bcs     L0008
;
; vram_adr(NTADR_A(2, row + 4));
;
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$04
	bcc     L000B
	inx
L000B:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$02
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; for (col = 0; col < 16; ++col) {
;
	lda     #$00
	ldy     #$01
L0012:	sta     (sp),y
	cmp     #$10
	bcs     L0009
;
; vram_put(tile_offset + row * 16 + col);
;
	iny
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	ldy     #$00
	adc     (sp),y
	sta     ptr1
	iny
	lda     (sp),y
	clc
	adc     ptr1
	jsr     _vram_put
;
; for (col = 0; col < 16; ++col) {
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L0012
;
; for (row = 0; row < 16; ++row) {
;
L0009:	iny
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0013
;
; ppu_on_all();
;
L0008:	jsr     _ppu_on_all
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; unsigned char pad_prev = 0;
;
	jsr     decsp1
	lda     #$00
	jsr     pusha
;
; mmc1_write(MMC1_CTRL, CTRL_MIRROR_V | CTRL_PRG_32K | CTRL_CHR_4K);
;
	ldx     #$80
	jsr     pushax
	lda     #$12
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR0, BANK0_TOP);  // Start with font bank
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, BANK0_TOP);  // Keep both banks on font
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_PRG, 0);   // PRG bank 0
;
	ldx     #$E0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; pal_col(0, palettes[0]);
;
	lda     #$00
	jsr     pusha
	lda     _palettes
	jsr     _pal_col
;
; pal_col(1, palettes[1]);
;
	lda     #$01
	jsr     pusha
	lda     _palettes+1
	jsr     _pal_col
;
; pal_col(2, palettes[2]);
;
	lda     #$02
	jsr     pusha
	lda     _palettes+2
	jsr     _pal_col
;
; pal_col(3, palettes[3]);
;
	lda     #$03
	jsr     pusha
	lda     _palettes+3
	jsr     _pal_col
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; ppu_wait_nmi();
;
L0002:	jsr     _ppu_wait_nmi
;
; pad_current = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	ldy     #$01
	sta     (sp),y
;
; if (pad_current != pad_prev) {
;
	lda     (sp),y
	jsr     pusha0
	ldy     #$02
	lda     (sp),y
	jsr     tosicmp0
	jeq     L0014
;
; if ((pad_current & PAD_A) && !(pad_prev & PAD_A)) {
;
	ldy     #$01
	lda     (sp),y
	and     #$80
	beq     L0025
	dey
	lda     (sp),y
	and     #$80
	bne     L0006
;
; current_bank = (current_bank + 1) & 3;
;
	lda     _current_bank
	clc
	adc     #$01
	and     #$03
	sta     _current_bank
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; if ((pad_current & PAD_B) && !(pad_prev & PAD_B)) {
;
L0006:	ldy     #$01
L0025:	lda     (sp),y
	and     #$40
	beq     L0026
	dey
	lda     (sp),y
	and     #$40
	bne     L000B
;
; show_bottom_half ^= 1;
;
	lda     _show_bottom_half
	eor     #$01
	sta     _show_bottom_half
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; if ((pad_current & PAD_UP) && !(pad_prev & PAD_UP)) {
;
L000B:	ldy     #$01
L0026:	lda     (sp),y
	and     #$08
	beq     L0027
	dey
	lda     (sp),y
	and     #$08
	bne     L000F
;
; current_palette = (current_palette + 9) % 10;
;
	tax
	lda     _current_palette
	clc
	adc     #$09
	bcc     L0013
	inx
L0013:	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     tosmoda0
	sta     _current_palette
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; if ((pad_current & PAD_DOWN) && !(pad_prev & PAD_DOWN)) {
;
L000F:	ldy     #$01
L0027:	lda     (sp),y
	and     #$04
	beq     L0028
	dey
	lda     (sp),y
	and     #$04
	bne     L0014
;
; current_palette = (current_palette + 1) % 10;
;
	tax
	lda     _current_palette
	clc
	adc     #$01
	bcc     L0018
	inx
L0018:	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     tosmoda0
	sta     _current_palette
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; pad_prev = pad_current;
;
L0014:	ldy     #$01
L0028:	lda     (sp),y
	dey
	sta     (sp),y
;
; while(1) {
;
	jmp     L0002

.endproc

