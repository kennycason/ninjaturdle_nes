;
; File generated by cc65 v 2.19 - Git 1406346
;
	.fopt		compiler,"cc65 v 2.19 - Git 1406346"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_pal_all
	.import		_pal_col
	.import		_pal_clear
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_spr
	.import		_oam_get
	.import		_pad_trigger
	.import		_vram_adr
	.import		_vram_put
	.export		_mmc1_write
	.export		_mmc1_init
	.export		_setup_pattern_tables
	.export		_fade_in_palette
	.export		_fade_out_palette
	.export		_create_sprite
	.export		_update_sprite_pos
	.export		_draw_border
	.export		_str_bank
	.export		_str_pt
	.export		_str_pal
	.export		_palettes
	.export		_draw_text_at
	.export		_draw_number_at
	.export		_draw_border_and_text
	.export		_draw_tile_grid
	.export		_bank_swap_main

.segment	"DATA"

_current_block:
	.byte	$00
_current_palette:
	.byte	$00

.segment	"RODATA"

_str_bank:
	.byte	$42,$41,$4E,$4B,$3A,$00
_str_pt:
	.byte	$50,$54,$3A,$00
_str_pal:
	.byte	$50,$41,$4C,$3A,$00
_palettes:
	.byte	$0F
	.byte	$00
	.byte	$10
	.byte	$30
	.byte	$0F
	.byte	$06
	.byte	$16
	.byte	$26
	.byte	$0F
	.byte	$09
	.byte	$19
	.byte	$29
	.byte	$0F
	.byte	$01
	.byte	$11
	.byte	$21
	.byte	$0F
	.byte	$08
	.byte	$18
	.byte	$28
	.byte	$0F
	.byte	$0A
	.byte	$1A
	.byte	$2A
	.byte	$0F
	.byte	$07
	.byte	$17
	.byte	$27
	.byte	$0F
	.byte	$02
	.byte	$12
	.byte	$22
	.byte	$0F
	.byte	$05
	.byte	$15
	.byte	$25
	.byte	$0F
	.byte	$03
	.byte	$13
	.byte	$23
S0004:
	.byte	$42,$41,$4E,$4B,$3A,$00
S0005:
	.byte	$50,$41,$4C,$3A,$00

; ---------------------------------------------------------------
; void __near__ mmc1_write (unsigned int address, unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_mmc1_write: near

.segment	"CODE"

;
; void mmc1_write(unsigned int address, unsigned char value) {
;
	jsr     pusha
;
; for (i = 0; i < 5; ++i) {
;
	jsr     decsp1
	lda     #$00
	tay
L0006:	sta     (sp),y
	cmp     #$05
	bcs     L0003
;
; *((unsigned char*)address) = value & 1;
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (sp),y
	and     #$01
	dey
	sta     (ptr1),y
;
; value = value >> 1;
;
	iny
	lda     (sp),y
	lsr     a
	sta     (sp),y
;
; for (i = 0; i < 5; ++i) {
;
	dey
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0006
;
; }
;
L0003:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ mmc1_init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_mmc1_init: near

.segment	"CODE"

;
; *((unsigned char*)MMC1_CONTROL) = 0x80;
;
	lda     #$80
	sta     $8000
;
; mmc1_write(MMC1_CONTROL, 0x12);  // 0001 0010
;
	tax
	lda     #$00
	jsr     pushax
	lda     #$12
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR0, 0);  // First 4KB bank
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, 0);  // Second 4KB bank
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	jmp     _mmc1_write

.endproc

; ---------------------------------------------------------------
; void __near__ setup_pattern_tables (unsigned char bg_bank, unsigned char spr_bank)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setup_pattern_tables: near

.segment	"CODE"

;
; void setup_pattern_tables(unsigned char bg_bank, unsigned char spr_bank) {
;
	jsr     pusha
;
; mmc1_write(MMC1_CHR0, bg_bank * 2);      // First 4KB
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	ldy     #$03
	lda     (sp),y
	asl     a
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, bg_bank * 2 + 1);  // Second 4KB
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	ldy     #$03
	lda     (sp),y
	asl     a
	clc
	adc     #$01
	jsr     _mmc1_write
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ fade_in_palette (const unsigned char *palette, unsigned char delay_frames)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_in_palette: near

.segment	"CODE"

;
; void fade_in_palette(const unsigned char *palette, unsigned char delay_frames) {
;
	jsr     pusha
;
; pal_clear();
;
	ldy     #$21
	jsr     subysp
	jsr     _pal_clear
;
; for (i = 0; i < 32; i++) {
;
	lda     #$00
	ldy     #$20
L000F:	sta     (sp),y
	cmp     #$20
	bcs     L0003
;
; temp_pal[i] = palette[i];
;
	lda     sp
	ldx     sp+1
	clc
	adc     (sp),y
	bcc     L0006
	inx
L0006:	sta     sreg
	stx     sreg+1
	ldy     #$23
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$20
	lda     (sp),y
	tay
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; pal_col(i, temp_pal[i]);
;
	ldy     #$20
	lda     (sp),y
	jsr     pusha
	lda     sp
	ldx     sp+1
	clc
	adc     #$01
	bcc     L0007
	inx
L0007:	ldy     #$21
	clc
	adc     (sp),y
	bcc     L0008
	inx
L0008:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jsr     _pal_col
;
; ppu_wait_nmi(); // Wait for NMI to complete
;
	jsr     _ppu_wait_nmi
;
; if (delay_frames > 0) {
;
	ldy     #$21
	lda     (sp),y
	beq     L0004
;
; for (j = 0; j < delay_frames; j++) {
;
	jsr     decsp1
	lda     #$00
	tay
L000E:	sta     (sp),y
	ldy     #$22
	cmp     (sp),y
	bcs     L000B
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; for (j = 0; j < delay_frames; j++) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L000E
;
; }
;
L000B:	jsr     incsp1
;
; for (i = 0; i < 32; i++) {
;
L0004:	ldy     #$20
	clc
	lda     #$01
	adc     (sp),y
	jmp     L000F
;
; }
;
L0003:	ldy     #$24
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; void __near__ fade_out_palette (unsigned char delay_frames)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_fade_out_palette: near

.segment	"CODE"

;
; void fade_out_palette(unsigned char delay_frames) {
;
	jsr     pusha
;
; for (i = 0; i < 32; i++) {
;
	ldy     #$22
	jsr     subysp
	lda     #$00
	ldy     #$21
L0019:	sta     (sp),y
	cmp     #$20
	bcs     L001D
;
; temp_pal[i] = 0x0F; // Default to black
;
	lda     sp+1
	sta     ptr1+1
	lda     sp
	sta     ptr1
	lda     (sp),y
	tay
	lda     #$0F
	sta     (ptr1),y
;
; for (i = 0; i < 32; i++) {
;
	ldy     #$21
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0019
;
; for (i = 0; i < 32; i++) {
;
L001D:	lda     #$00
L001C:	sta     (sp),y
	cmp     #$20
	jcs     L0008
;
; for (j = 0; j < 32; j++) {
;
	lda     #$00
	dey
L001A:	sta     (sp),y
	cmp     #$20
	bcs     L000C
;
; if (temp_pal[j] > 0) {
;
	lda     sp
	ldx     sp+1
	clc
	adc     (sp),y
	bcc     L0010
	inx
L0010:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L000D
;
; temp_pal[j]--;
;
	lda     sp
	ldx     sp+1
	ldy     #$20
	clc
	adc     (sp),y
	bcc     L0011
	inx
L0011:	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$01
	sta     (sreg),y
;
; pal_col(j, temp_pal[j]);
;
	ldy     #$20
	lda     (sp),y
	jsr     pusha
	lda     sp
	ldx     sp+1
	clc
	adc     #$01
	bcc     L0012
	inx
L0012:	ldy     #$21
	clc
	adc     (sp),y
	bcc     L0013
	inx
L0013:	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jsr     _pal_col
;
; for (j = 0; j < 32; j++) {
;
L000D:	ldy     #$20
	clc
	lda     #$01
	adc     (sp),y
	jmp     L001A
;
; ppu_wait_nmi();
;
L000C:	jsr     _ppu_wait_nmi
;
; if (delay_frames > 0) {
;
	ldy     #$22
	lda     (sp),y
	beq     L0009
;
; for (k = 0; k < delay_frames; k++) {
;
	jsr     decsp1
	lda     #$00
	tay
L001B:	sta     (sp),y
	ldy     #$23
	cmp     (sp),y
	bcs     L0016
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; for (k = 0; k < delay_frames; k++) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L001B
;
; }
;
L0016:	jsr     incsp1
;
; for (i = 0; i < 32; i++) {
;
L0009:	ldy     #$21
	clc
	lda     #$01
	adc     (sp),y
	jmp     L001C
;
; }
;
L0008:	ldy     #$23
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ create_sprite (unsigned char x, unsigned char y, unsigned char tile, unsigned char palette, unsigned char flip_h, unsigned char flip_v, unsigned char behind)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_create_sprite: near

.segment	"CODE"

;
; unsigned char flip_v, unsigned char behind) {
;
	jsr     pusha
;
; unsigned char attr = palette;
;
	ldy     #$03
	lda     (sp),y
	jsr     pusha
;
; if (flip_h) attr |= OAM_FLIP_H;
;
	ldy     #$03
	lda     (sp),y
	beq     L0002
	ldy     #$00
	lda     (sp),y
	ora     #$40
	sta     (sp),y
;
; if (flip_v) attr |= OAM_FLIP_V;
;
L0002:	ldy     #$02
	lda     (sp),y
	beq     L0003
	ldy     #$00
	lda     (sp),y
	ora     #$80
	sta     (sp),y
;
; if (behind) attr |= OAM_BEHIND;
;
L0003:	ldy     #$01
	lda     (sp),y
	beq     L0004
	dey
	lda     (sp),y
	ora     #$20
	sta     (sp),y
;
; oam_spr(x, y, tile, attr);
;
L0004:	jsr     decsp3
	ldy     #$0A
	lda     (sp),y
	ldy     #$02
	sta     (sp),y
	ldy     #$09
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	ldy     #$08
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$03
	lda     (sp),y
	jsr     _oam_spr
;
; return oam_get();
;
	jsr     _oam_get
;
; }
;
	jmp     incsp8

.endproc

; ---------------------------------------------------------------
; void __near__ update_sprite_pos (unsigned char index, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_sprite_pos: near

.segment	"CODE"

;
; void update_sprite_pos(unsigned char index, unsigned char x, unsigned char y) {
;
	jsr     pusha
;
; oam_spr(x, y, 0, 0); // Use default attributes
;
	jsr     decsp3
	ldy     #$04
	lda     (sp),y
	ldy     #$02
	sta     (sp),y
	iny
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	lda     #$00
	dey
	sta     (sp),y
	jsr     _oam_spr
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ draw_border (unsigned char x, unsigned char y, unsigned char width, unsigned char height)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_border: near

.segment	"CODE"

;
; void draw_border(unsigned char x, unsigned char y, unsigned char width, unsigned char height) {
;
	jsr     pusha
;
; for(row = 0; row < height; row++) {
;
	jsr     decsp2
	lda     #$00
	ldy     #$01
L000C:	sta     (sp),y
	iny
	cmp     (sp),y
	bcs     L0003
;
; vram_adr(NTADR_A(x, y + row));
;
	ldx     #$00
	dey
	lda     (sp),y
	clc
	ldy     #$04
	adc     (sp),y
	bcc     L000A
	inx
L000A:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; for(col = 0; col < width; col++) {
;
	lda     #$00
	tay
L000B:	sta     (sp),y
	ldy     #$03
	cmp     (sp),y
	bcs     L0004
;
; vram_put(TILE_BLANK);
;
	lda     #$FF
	jsr     _vram_put
;
; for(col = 0; col < width; col++) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L000B
;
; for(row = 0; row < height; row++) {
;
L0004:	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L000C
;
; }
;
L0003:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ draw_text_at (unsigned char x, unsigned char y, const char *str)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_text_at: near

.segment	"CODE"

;
; void draw_text_at(unsigned char x, unsigned char y, const char* str) {
;
	jsr     pushax
;
; vram_adr(NTADR_A(x, y));
;
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; while (*str) {
;
	jmp     L0004
;
; vram_put(*str - 0x20);
;
L0002:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	sec
	sbc     #$20
	jsr     _vram_put
;
; str++;
;
	ldx     #$00
	lda     #$01
	jsr     addeq0sp
;
; while (*str) {
;
L0004:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	bne     L0002
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ draw_number_at (unsigned char x, unsigned char y, unsigned char num)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_number_at: near

.segment	"CODE"

;
; void draw_number_at(unsigned char x, unsigned char y, unsigned char num) {
;
	jsr     pusha
;
; vram_adr(NTADR_A(x, y));
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put('0' + num - 0x20);
;
	ldy     #$00
	lda     (sp),y
	clc
	adc     #$30
	sec
	sbc     #$20
	jsr     _vram_put
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ draw_border_and_text (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_border_and_text: near

.segment	"CODE"

;
; mmc1_write(MMC1_CHR0, 0);
;
	jsr     decsp2
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, 0);  // Keep both banks on font
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; vram_adr(NTADR_A(1,3));
;
	ldx     #$20
	lda     #$61
	jsr     _vram_adr
;
; for(col = 0; col < 18; ++col) vram_put(0x00);
;
	lda     #$00
	tay
L0010:	sta     (sp),y
	cmp     #$12
	bcs     L0013
	tya
	jsr     _vram_put
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0010
;
; for(row = 0; row < 16; ++row) {
;
L0013:	tya
	iny
L0011:	sta     (sp),y
	cmp     #$10
	bcs     L0007
;
; vram_adr(NTADR_A(1, row + 4));
;
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$04
	bcc     L000A
	inx
L000A:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$01
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; vram_adr(NTADR_A(18, row + 4));
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$04
	bcc     L000B
	inx
L000B:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$12
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0x00);
;
	lda     #$00
	jsr     _vram_put
;
; for(row = 0; row < 16; ++row) {
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L0011
;
; vram_adr(NTADR_A(1,20));
;
L0007:	ldx     #$22
	lda     #$81
	jsr     _vram_adr
;
; for(col = 0; col < 18; ++col) vram_put(0x00);
;
	lda     #$00
	tay
L0012:	sta     (sp),y
	cmp     #$12
	bcs     L000D
	tya
	jsr     _vram_put
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0012
;
; vram_adr(NTADR_A(2,2));
;
L000D:	ldx     #$20
	lda     #$42
	jsr     _vram_adr
;
; draw_text_at(2, 2, "BANK:");
;
	jsr     decsp2
	lda     #$02
	ldy     #$01
	sta     (sp),y
	dey
	sta     (sp),y
	lda     #<(S0004)
	ldx     #>(S0004)
	jsr     _draw_text_at
;
; draw_number_at(7, 2, current_block);
;
	jsr     decsp2
	lda     #$07
	ldy     #$01
	sta     (sp),y
	lda     #$02
	dey
	sta     (sp),y
	lda     _current_block
	jsr     _draw_number_at
;
; vram_adr(NTADR_A(18,2));
;
	ldx     #$20
	lda     #$52
	jsr     _vram_adr
;
; draw_text_at(18, 2, "PAL:");
;
	jsr     decsp2
	lda     #$12
	ldy     #$01
	sta     (sp),y
	lda     #$02
	dey
	sta     (sp),y
	lda     #<(S0005)
	ldx     #>(S0005)
	jsr     _draw_text_at
;
; draw_number_at(22, 2, current_palette);
;
	jsr     decsp2
	lda     #$16
	ldy     #$01
	sta     (sp),y
	lda     #$02
	dey
	sta     (sp),y
	lda     _current_palette
	jsr     _draw_number_at
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ draw_tile_grid (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_tile_grid: near

.segment	"CODE"

;
; pal_col(0, palettes[current_palette * 4 + 0]);
;
	jsr     decsp2
	lda     #$00
	jsr     pusha
	tax
	lda     _current_palette
	jsr     shlax2
	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; pal_col(1, palettes[current_palette * 4 + 1]);
;
	lda     #$01
	jsr     pusha
	ldx     #$00
	lda     _current_palette
	jsr     shlax2
	clc
	adc     #$01
	bcc     L0002
	inx
L0002:	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; pal_col(2, palettes[current_palette * 4 + 2]);
;
	lda     #$02
	jsr     pusha
	ldx     #$00
	lda     _current_palette
	jsr     shlax2
	clc
	adc     #$02
	bcc     L0003
	inx
L0003:	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; pal_col(3, palettes[current_palette * 4 + 3]);
;
	lda     #$03
	jsr     pusha
	ldx     #$00
	lda     _current_palette
	jsr     shlax2
	clc
	adc     #$03
	bcc     L0004
	inx
L0004:	sta     ptr1
	txa
	clc
	adc     #>(_palettes)
	sta     ptr1+1
	ldy     #<(_palettes)
	lda     (ptr1),y
	jsr     _pal_col
;
; ppu_off();
;
	jsr     _ppu_off
;
; mmc1_write(MMC1_CTRL, 0x12);  // Ensure 4KB mode is set
;
	ldx     #$80
	lda     #$00
	jsr     pushax
	lda     #$12
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR0, current_block);
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	lda     _current_block
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, current_block);
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	lda     _current_block
	jsr     _mmc1_write
;
; for (row = 0; row < 16; ++row) {
;
	lda     #$00
	ldy     #$01
L0010:	sta     (sp),y
	cmp     #$10
	bcs     L0006
;
; vram_adr(NTADR_A(2, row + 4));
;
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$04
	bcc     L0009
	inx
L0009:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$02
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; for (col = 0; col < 16; ++col) {
;
	lda     #$00
	tay
L000F:	sta     (sp),y
	cmp     #$10
	bcs     L0007
;
; vram_put(row * 16 + col);
;
	iny
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	asl     a
	sta     ptr1
	dey
	lda     (sp),y
	clc
	adc     ptr1
	jsr     _vram_put
;
; for (col = 0; col < 16; ++col) {
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L000F
;
; for (row = 0; row < 16; ++row) {
;
L0007:	iny
	clc
	tya
	adc     (sp),y
	jmp     L0010
;
; ppu_on_all();
;
L0006:	jsr     _ppu_on_all
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ bank_swap_main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_bank_swap_main: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; mmc1_write(MMC1_CTRL, 0x80);  // Reset
;
	ldx     #$80
	lda     #$00
	jsr     pushax
	txa
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CTRL, 0x12);  // 4KB mode, vertical mirroring
;
	ldx     #$80
	lda     #$00
	jsr     pushax
	lda     #$12
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR0, 0);
;
	ldx     #$A0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; mmc1_write(MMC1_CHR1, 0);
;
	ldx     #$C0
	lda     #$00
	jsr     pushax
	jsr     _mmc1_write
;
; pal_all(palettes);
;
	lda     #<(_palettes)
	ldx     #>(_palettes)
	jsr     _pal_all
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; char input = pad_trigger(0);
;
L0002:	lda     #$00
	jsr     _pad_trigger
	jsr     pusha
;
; if (input & PAD_A) {
;
	ldy     #$00
	lda     (sp),y
	and     #$80
	beq     L000D
;
; current_block = (current_block + 1) % 4;  // Cycle through all 4 blocks
;
	ldx     #$00
	lda     _current_block
	clc
	adc     #$01
	bcc     L0006
	inx
L0006:	jsr     pushax
	ldx     #$00
	lda     #$04
	jsr     tosmoda0
	sta     _current_block
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; if (input & PAD_UP) {
;
	ldy     #$00
L000D:	lda     (sp),y
	and     #$08
	beq     L000F
;
; current_palette = (current_palette + 1) % NUM_PALETTES;
;
	ldx     #$00
	lda     _current_palette
	clc
	adc     #$01
	bcc     L0008
	inx
L0008:	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     tosmoda0
	sta     _current_palette
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; if (input & PAD_DOWN) {
;
	ldy     #$00
L000F:	lda     (sp),y
	and     #$04
	beq     L0009
;
; current_palette = (current_palette + NUM_PALETTES - 1) % NUM_PALETTES;
;
	ldx     #$00
	lda     _current_palette
	clc
	adc     #$0A
	bcc     L000A
	inx
L000A:	sec
	sbc     #$01
	bcs     L000B
	dex
L000B:	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     tosmoda0
	sta     _current_palette
;
; draw_tile_grid();
;
	jsr     _draw_tile_grid
;
; ppu_wait_nmi();
;
L0009:	jsr     _ppu_wait_nmi
;
; }
;
	jsr     incsp1
;
; while(1)
;
	jmp     L0002

.endproc

