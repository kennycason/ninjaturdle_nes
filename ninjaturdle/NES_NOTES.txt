Hello, I'm a complete newbie when it comes to developing for the NES. I have been playing around with NESlib and followed nesdoug's tutorials.

I've been messing with the source for the platformer tutorial.
https://nesdoug.com/2018/09/11/21-finished-platformer/

I'm just having an issue trying to wrap my brain around implementing horizontal and vertical scrolling a la Metroid, let alone scroll back in the level.

Joined: Tue May 28, 2013 5:49 am
Location: Hokkaido, Japan
Re: Multi-Direction Scrolling
Post by Pokun » Wed Dec 06, 2023 1:05 pm

Normally you just let the scroll coordinates (that are written to $2005 and the high bits in $2000 nametable select) wrap around at 255 to 0 (and vice versa). You have to update the part of the screen that currently is outside the scroll viewport to create the illusion that the screen is several screens long.

Note that the Y-scroll coordinate wraps after 239 instead of after 255 so you would have to manually make sure that your scroll engine is adjusted to never use values 240-255 for the Y-scroll coordinate and wrap properly. In other words 230 + 30 = 20 and not 5 (which would be the case if wrapping after 255).

Also depending on which nametable arrangement (AKA nametable mirroring) you are using you will have either one or two nametables to scroll through in each axis. Metroid switches the arangement so that it always has two screens but it can only scroll in one axis at a time (depending on if you are in a corridor or a shaft).

There is also the Nerdy Nights scrolling tutorial if you need more examples.
The technical details are found on the wiki.

Joined: Fri Nov 12, 2004 2:49 pm
Location: Divonne-les-bains, France
Re: Multi-Direction Scrolling
Post by Bregalad » Sat Dec 09, 2023 2:59 pm

Really, the first thing to do before tempting to code any multidirectional scrolling demo is to open your favourite games in FCEUltra emulator and use the Nametable viewer with the scroll bars. This is immensely useful in understanding what's happening in VRAM when a game is scrolling, and explaining the same thing with text would be much longer and more confusing than figuring it out by yourself.


----


Nametable Mirroring
Nametable mirroring affects what is shown past the right and bottom edges of the current nametable. When mirroring is enabled for a particular axis (horizontal and/or vertical), the coordinates simply wrap around on the current nametable. A background "mirrored" in this way is repeated, not flipped. When mirroring is disabled, a second nametable is used. There are four common combinations of mirroring:

Horizontal
Horizontal mirroring diagram.png
A vertical arrangement of the nametables results in horizontal mirroring, which makes a 32x60 tilemap.

This is most commonly used for games which only scroll vertically or in all directions.

Doing any horizontal scrolling using horizontal mirroring is hard to do smoothly because the data on the right of the screen is immediately show on the left due to mirroring. Clever use of hardware left-side screen clipping will hide all name table glitches, but because the attribute tables have a resolution of 2x2 tiles, there will always be attribute glitches on the left and/or the right side of the screen. The best possible way to hide it is to have 4 pixels with potentially wrong attributes on both sides, but most commercial games did worse than that having usually 8 or even more glitchy pixels, so that is why so many NES games have color glitches on the border of the screen.

Some televisions overscan up to 8 pixels on both left and right border, but most don't. Perfectionist programmers could use solid black sprites on the right border to hide attribute glitches and make the screen look symmetrical and hide absolutely all attribute glitches, as in the game Alfred Chicken, but very few games do this because it reduces the number of sprites per scanline to 7 and wastes a lot of OAM space (roughly 1/4 in 8x16 pixel sprite mode).

To configure a cartridge board for horizontal mirroring, connect PPU A11 to CIRAM A10. On cartridge boards made by Nintendo, this is selected by shorting the "V" solder pad (for "vertical arrangement").

Vertical
Vertical mirroring diagram.png
A horizontal arrangement of the nametables results in vertical mirroring, which makes a 64x30 tilemap.

This is most commonly used for games which only scroll horizontally. Games that scroll vertically (by any amount and without status bar) and that never scroll horizontally by more than one screen would use this mirroring (e.g. Lode Runner, Bomberman, Fire Emblem, Crystal Mines), so that they don't have to load anything when scrolling horizontally.

Of course it is also used for games which scroll in both directions without a status bar. Because data that is on the top/bottom of the screen will immediately show up on the other side, a clever use of NTSC overscan can make it glitch-less multidirectional scrolling, but glitches will appear on PAL televisions (and NTSC televisions with a overscan range which is a little off). The best possible way to hide glitches is to make 4 pixels with wrong tiles and 4 additional pixels with wrong color on both sides, but most commercial games did much worse than this, that's why they look so bad if overscan is disabled.

Perfectionist programmers could use raster split to hide glitches (and possibly also provide more blanking time to update VRAM) as in the games Jurassic Park and M.C. Kids, but it was rarely done because it complicates the code a lot for little benefits.

To configure a cartridge board for vertical mirroring, connect PPU A10 to CIRAM A10. On cartridge boards made by Nintendo, this is selected by shorting the "H" solder pad (for "horizontal arrangement").

Single-Screen
Single screen mirroring diagram overlaid.png
Single-screen mirroring is only available with certain mappers, such as the AxROM, SxROM, and TLSROM boards, resulting in two 32x30 tilemaps.

Its main advantage is that it allows using a status bar at the top or bottom of the screen while also allowing the playfield to extend equally in any direction - this can be done by storing the status bar in one nametable, rendering the playfield in the other nametable, and switching mirroring (and scrolling parameters) at the appropriate screen location during rendering.

There are also a lot of other things that can be drastically simplified when using 1-screen mirroring: The formulas used to calculate PPU address of data to be updated to the screen are also significantly simpler, and if the status bar have a variable size or is scrolling, all this would be a headache without 1-screen mirroring.

When this mirroring is used to scroll horizontally, similar glitches and scrolling problems that those of horizontal mirroring will happen. However, as long as there is a status bar, no glitches will happen vertically since the data that falls off the bottom (or the top) of the screen will come in the area that is "hidden" by the status bar, regardless of overscan factors.

There are several different ways to configure a cartridge board for single-screen mirroring. Some boards have single screen mirroring which is mapper controlled like the MMC1 and AxROM. For AxROM connect the output of a register (e.g. 74HC161) to CIRAM A10 (AxROM latches PRG D4). A simpler way to create one screen mirroring that's fixed (non-changable by software) is to simply connect CIRAM A10 to Gnd or Vcc. The board that implements iNES Mapper 218 wires CIRAM A10 to PPU A10, A11, A12, or A13, so that the game can store tiles in CIRAM without having any CHR ROM or CHR RAM in the cartridge.


----

Advanced Tutorial Series
Chapters
Advanced Nerdy Nights #1: CHR Bank switching
Advanced Nerdy Nights #2: MMC1 CHR and PRG Bank switching, WRAM + Battery
Advanced Nerdy Nights #3: Horizontal background scrolling
Advanced Nerdy Nights #4: Sprite 0 hit for a status bar
Advanced Nerdy Nights #1: CHR Bank switching
To do the advanced lessons you should have already finished Pong.

This Week: As you complete a full game you may find the NROM memory limits to be too small. To enable more ROM on carts many forms of "bank switching" were used. This article deals with just one type of CHR switching, used on CNROM carts. CNROM is easy to use and very cheap to manufacture. The ReproPak, PowerPak, and PowerPak Lite all support CNROM completely so it is easy to get your code running on real hardware. If you are using donor carts you can look up games that use CNROM at BootGod's NES Cart Database.


CHR Bank Switching
Bank switching is exchanging one chunk of ROM for a different chunk, while keeping everything in same address range. It is not making a copy, so it happens instantly. You can switch between different banks whenever you want. The size and memory range of the banks depends on the mapper. For the CNROM mapper used in this article the bank size is 8KB of CHR ROM. The whole 8KB range of PPU memory $0000-1FFF is switched at once. This means the graphics for all background tiles and sprite tiles will be swapped. In your game you may have some tiles duplicated in multiple banks so they do not appear to change on screen. PRG is not bank switched, so it remains at the NROM limit of 32KB.


Set Mapper Number
The first part of adding bank switching is changing the mapper number your .NES file uses. At the top of your code has previously been:

  .inesmap 0 ; mapper 0 = NROM, no bank swapping


The new line is:
  .inesmap 3 ; mapper 3 = CNROM, 8KB CHR ROM bank swapping


This line in the header just tells the emulator to use CNROM to play your game. A list of other iNES mapper numbers can be seen at the wiki at http://nesdevwiki.org/....


Set CHR Size
The next part is to increase the size of your CHR ROM. Change the .ineschr value from 1 to 2, showing that there are now two 8KB banks. CNROM can handle 32KB of CHR ROM or four 8KB banks but this example will only use two.


Add CHR Data
The third part adds the data for the next bank into your game. Just make a new .bank statement below your current one for CHR, giving it the next sequential number. In your code when you set which bank to switch to this is the number used. PRG bank numbers are ignored so your original CHR bank will be #0 and the new one will be #1.


Bank Switching Code
The final part it to write your bank switching code. This subroutine will take a bank number in the A register and switch the CHR bank to it immediately. The actual switch is done by writing the desired bank number anywhere in the $8000-FFFF memory range. The cart hardware sees this write and changes the CHR bank.


... your game code ...

  LDA #$01 ;;put new bank to use into the A register

  JSR Bankswitch ;;jump to bank switching code

... your game code ...


Bankswitch:

  STA $8000 ;;new bank to use

  RTS



Bus Conflicts
When you start running your code on real hardware there is one catch to worry about. For basic mappers, the PRG ROM does not care if it receives a read or a write command. It will respond to both like a read by putting the data on the data bus. This is a problem for bank switching, where the CPU is also trying to put data on the data bus at the same time. They electrically fit in a "bus conflict". The CPU could win, giving you the right value. Or the ROM could win, giving you the wrong value. This is solved by having the ROM and CPU put the same value on the data bus, so there is no conflict. First a table of bank numbers is made, and the value from that table is written to do the bank switch.

... code ...

  LDA #$01 ;;put new bank to use into A

  JSR Bankswitch ;;jump to bank switching code

... code ...


Bankswitch:

  TAX ;;copy A into X

  STA Bankvalues, X ;;new bank to use

  RTS


Bankvalues:

  .db $00, $01, $02, $03 ;;bank numbers


The X register is used as an index into the Bankvalues table, so the value written by the CPU will match the value coming from the ROM.



Putting It All Together
Download and unzip the chrbanks.zip sample files. This set is based on the previous Week 5 code. Make sure that file, mario0.chr, mario1.chr, and chrbanks.bat is in the same folder as NESASM3, then double click on chrbanks.bat. That will run NESASM3 and should produce chrbanks.nes. Run that NES file in FCEUXD SP to see small Mario.

Inside the LatchController subroutine a new section is added to read the Select and Start buttons from the controller. The Select button switches to CHR bank 0, and the Start button switches to CHR bank 1. Graphics of CHR bank 1 have been rearranged so Mario will change to a beetle.  The tile numbers are not changed, but the graphics for those tiles are.

Open the PPU Viewer from the Tools menu in FCEUXD SP and try hitting the buttons.  You can see all the graphics changing at once when the active bank switches.
Back to Table of Contents Toggle CommentsOriginal Article
Advanced Nerdy Nights #2: MMC1 CHR and PRG Bank switching, WRAM + Battery
This Week: The MMC1 is the first advanced mapper made by Nintendo. It is used for many games including top titles like The Legend of Zelda. The main benefits are mirroring control, up to 256KB of PRG ROM, 128KB of CHR RAM or ROM, and 8KB of WRAM. The WRAM can be battery backed for saved games. This tutorial will cover all features of the MMC1 and how to use them. You should be comfortable with the normal Nerdy Nights series before starting.  Another more simple lesson for bankswitching is Advanced Nerdy Nights #1.  If you only need one or two of the banking features then you may want to consider more simple and cheaper mappers instead such as UNROM or CNROM.

Carts using the MMC1 will have the S*ROM board code, like SNROM and SGROM. BootGod's NesCartDB database can be searched for which games use which boards. The ReproPak MMC1 board can also be used to build carts.


Shift Registers
The MMC1 uses a 5 bit shift register to temporarily store the banking bits. Shift registers were covered in Week 7. When writing to the register data comes in from data bit 0 only. This is similar to the controller reading where data outputs to data bit 0. Every time a write happens the current bits are shifted and D0 is inserted. The first bit you write eventually becomes to lowest bank bit. On the 5th write when the shift register is full the 5 bit value gets copied to the banking register. At this point the bank switch happens immediately without any delays. To load a bank register the LSR instruction is used for shifting:
  LDA banknumber
  STA bankreg    ; load bank bit 0 to shift register from data bit 0
  LSR A          ; shift in next data bit to position 0
  STA bankreg    ; load bank bit 1 from data bit 0
  LSR A
  STA bankreg    ; bank bit 2
  LSR A
  STA bankreg    ; bank bit 3
  LSR A
  STA bankreg    ; bank bit 4, bank register loaded, bank switch happens here

Unlike other simple mappers like UNROM and CNROM, there are no bus conflicts. The ROM is not enabled while you are writing so you do not have to make the data you are writing match.

Data bit 7 is also connected to the MMC1. When a write happens to any banking register with D7=1 the shift register is reset back to position 0. It will then take another 5 writes to fully load the next value. All other bits are ignored and D0 is not loaded into the shift register. The PRG bits of the control register are also reset to their default values as shown in the next section. Usually you will only reset the MMC1 at the very beginning of your program:
  LDA #%10000000
  STA $8000

Config Register at $8000-9FFF
To load the config register, do 5 writes to the $8000-9FFF range. The config bits are:

  43210
  -----
  CPRMM
  |||||
  |||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
  |||               2: vertical; 3: horizontal)
  ||+--- PRG swap range (0: switch 16 KB bank at $C000; 1: switch 16 KB bank at $8000;
  ||                            only used when PRG bank mode bit below is set to 1)
  |+---- PRG size (0: switch 32 KB at $8000, ignoring low bit of bank number;
  |                         1: switch 16 KB at address specified by location bit above)
  +----- CHR size (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)

Mirroring Config
Your program can change the mirroring at any point using these bits. You do not need to wait for vblank to change them. When using the MMC1 the .inesmir directive bit is ignored. You must set it through your code. Mirroring set to 0 and 1 are single screen mirroring modes. Only 1KB is used for all nametables. When scrolling the screen will wrap both vertically and horizontally. Mirroring set to 2 is the typical vertical mirroring, and 3 is horizontal mirroring.

PRG Bank Size Config
The MMC1 swaps PRG ROM in either 16KB or 32KB chunks. By default this bit is set to 1 for 16KB banks. Clearing it to 0 enables 32KB banks. Notice these are not the same size as the 8KB NESASM banks so the bank numbers will be different. When using 16KB banks the MMC1 banks are twice as big, so you must divide your NESASM bank number by 2 when writing it to the bank register. When using 32KB banks you must divide by 4. 16KB banks is most commonly used, with the bulk of the code in the fixed bank and data/graphics/music in the swappable banks.

PRG Swap Range Config
When using 16KB banks set above, the PRG address range that gets swapped can be configured. If 32KB banks are used this bit is ignored and the entire $8000-FFFF range is swapped at once.

By default this bit is set to 1, making the $8000-BFFF range swappable while the $C000-FFFF range is fixed to the last bank Of PRG. This matches the PRG swapping of the UNROM mapper and is most commonly used. Clearing this bit to 0 changes this so $8000-BFFF is fixed and $C000-FFFF is swappable.

Changing the range or bank size can be useful for swapping audio samples but you have to be careful to put IRQ/reset/NMI vectors in all banks that are loaded into the vector area at $FFFA-FFFF.

CHR Bank Size Config
Like the PRG the CHR bank size can be configured to either 4KB or 8KB banks. With 8KB banks the whole $0000-1FFF range is one bank. With 4KB banks there are two banks at PPU $0000-0FFF and $1000-1FFF. This can be used with background in one bank and sprites in another. Then, for example, all sprites could be swapped and the background could stay.


CHR Bank 0 Register at $A000-BFFF
This is the register for CHR bank 0. To set it do 5 writes to the $A000-BFFF range. When in 4KB CHR mode it selects a bank for PPU $0000-0FFF. The full 5 bit value is used so there are 32 possible banks. Each bank is 4KB making it 128KB CHR maximum. When in 8KB CHR mode this register controls the full PPU $0000-1FFF. The bottom bit is ignored so there are 16 possible banks. Each bank is now 8KB which is still 128KB max.

4KB mode	8KB mode
controls $0000-0FFF	controls $0000-1FFF
bottom bit is ignored


CHR Bank 1 Register at $C000-DFFF
This is the register for CHR bank 1. To set it do 5 writes to the $C000-DFFF range. When in 4KB CHR mode it selects a bank for PPU $1000-1FFF. When in 8KB CHR mode it is completely ignored.

4KB mode	8KB mode
controls $1000-1FFF	register ignored





PRG Bank Register at $E000-FFFF
This is the register for PRG banking. To set it do 5 writes to the $E000-FFFF range. The bits are:

  43210
  -----
  WPPPP
  |||||
  |++++- Select a PRG ROM bank (low bit ignored in 32 KB mode)
  +----- WRAM chip enable (0: enabled; 1: disabled)

In 16KB PRG mode it selects a 16KB PRG bank for the current swappable address range. Only the 4 lower bits are used for 16 possible PRG banks. That is 256KB maximum. In 32KB PRG mode it selects a 32KB bank for the $8000-FFFF range. Only bits 3-1 are used for 8 possible banks. Bit 0 is ignored. 

16KB mode
swap=0	16KB mode
swap=1	32KB mode
controls $C000-FFFF	controls $8000-BFFF (default setting)	controls $8000-FFFF
low bit ignored


WRAM
Bit 5 of the PRG Bank register also controls WRAM access. Clear this bit to enable WRAM access. Setting the bit to 1 disables the WRAM. If the WRAM is used for saved games it is usually disabled when it is not being accessed to prevent unwanted writes from corrupting the saves when the console is reset.

To use WRAM in your program nothing needs to be changed in the iNES header. The emulator will assume there is WRAM based on the mapper number. Next you need to enable the WRAM in the PRG Bank register. With that bit at 0 you can now use the WRAM. It is just plain RAM that you can read or write at the $6000-7FFF range. Like the console RAM the contents are unknown when the console is powered on. All RAM is cleared to unknown values when power is removed. However the RAM is not cleared when just the reset button is pushed. Power is still going to the cart so the RAM is still valid. This can be useful for telling if the console was just turned on or was only reset.

To add a battery to the WRAM, set the .inesmir directive to 2 in the iNES header. Now read and write to the WRAM normally. When power is removed the RAM contents will remain. The emulator will create an 8KB .sav file for the WRAM, however some emulators will not do this unless you have done some WRAM access.


Banking Routines
Keeping track of all the register addresses and bits can get confusing, so a few simple routines are used instead. In general subroutines should be used for even simple bank switching so the mapper can be changed more easily later. Only the most commonly used Config and PRG Bank register routines are shown here, it is your job to write the others.

ConfigWrite:        ; make sure this is in a fixed PRG bank so the RTS doesn't get swapped away
  LDA #$80
  STA $8000         ; reset the shift register
  LDA #%00001110    ; 8KB CHR, 16KB PRG, $8000-BFFF swappable, vertical mirroring
  STA $8000         ; first data bit
  LSR A             ; shift to next bit
  STA $8000         ; second data bit
  LSR A             ; etc
  STA $8000
  LSR A
  STA $8000
  LSR A
  STA $8000         ; config bits written here, takes effect immediately
  RTS

PRGBankWrite:       ; make sure this is in a fixed bank so it doesnt get swapped away
  LDA bankNumber    ; get bank number into A
  STA $E000         ; first data bit
  LSR A             ; shift to next bit
  STA $E000
  LSR A
  STA $E000
  LSR A
  STA $E000
  LSR A
  STA $E000         ; bank switch happens immediately here
  RTS

Putting It All Together
Download and unzip the cyoammc1.zip sample files. The CYOA code has been changed to the MMC1 mapper. Running the cyoammc1.bat file will create cyoammc1.nes, which will run in an emulator. This sample uses 8KB of CHR RAM so no CHR banking has been included. The changes from UNROM PRG mapping are minimal. Some of the variables have been moved to the WRAM area to show how to use it. An example of using WRAM to detect reset is also included in resetCount. Try changing the battery info in the iNES header to see how it makes resetCount change between power and resets.





Back to Table of Contents Toggle CommentsOriginal Article
Advanced Nerdy Nights #3: Horizontal background scrolling
This Week: Time to learn how to do horizontal background scrolling, like Super Mario Bros. Hopefully it is explained with the most easy to understand code. There is no compression, no buffers, and no metatiles, so only the ideas of scrolling are presented. Once you understand the scrolling part you should look into those other topics to save code/data space and increase performance if needed.



Nametable Review
Before starting the scrolling you must fully understand how nametables work. One nametable is 32x30 background tiles, which covers exactly one visible screen. Including the attribute table, each screen needs 1KB of PPU RAM. The NES PPU has the address space for 4 nametables ($2000, $2400, $2800, $2C00) in a 2x2 grid:
       +-----------+-----------+
       |           |           |
       |           |           |
       |   $2000   |   $2400   |
       |           |           |
       |           |           |
       +-----------+-----------+
       |           |           |
       |           |           |
       |   $2800   |   $2C00   |
       |           |           |
       |           |           |
       +-----------+-----------+
However the NES only has 2KB of PPU RAM inside the console, so there are only two actual nametables. The other two nametables are copies of those actual ones. Your mirroring settings determine the layout of the actual nametables and which ones are copies.

Vertical mirroring means the nametables stacked vertically are the same data. 0 ($2000) is a mirror of 2 ($2800), and 1 ($2400) is a mirror of 3 ($2C00). 0 and 1 are next to each other and have different data. This is what we want for horizontal scrolling. When you are looking at nametable 0 and scroll to the right, nametable 1 will be in view. Typically your mirroring setting is the opposite of the scrolling direction. To set the iNES header:
  .inesmir 1  ;;VERT mirroring for HORIZ scrolling

Scroll registers
Before scrolling we will fill both nametables 0 ($2000) and 1 ($2400). The same data will be copied into both, except the attribute table will be different. By setting the second nametable attributes to another color palette the two screens will have a very visible difference.
FillNametables:
  LDA $2002             ; read PPU status to reset the high/low latch
  LDA #$20
  STA $2006             ; write the high byte of $2000 address (nametable 0)
  LDA #$00
  STA $2006             ; write the low byte of $2000 address
  LDY #$08
  LDX #$00              ; fill 256 x 8 bytes = 2KB, both nametables all full
  LDA #$7F
FillNametablesLoop:
  STA $2007
  DEX
  BNE FillNametablesLoop
  DEY
  BNE FillNametablesLoop
FillAttrib0:
  LDA $2002             ; read PPU status to reset the high/low latch
  LDA #$23
  STA $2006             ; write the high byte of $23C0 address (nametable 0 attributes)
  LDA #$C0
  STA $2006             ; write the low byte of $23C0 address
  LDX #$40              ; fill 64 bytes
  LDA #$00              ; palette group 0
FillAttrib0Loop:
  STA $2007
  DEX
  BNE FillAttrib0Loop
FillAttrib1:
  LDA $2002             ; read PPU status to reset the high/low latch
  LDA #$27
  STA $2006             ; write the high byte of $27C0 address (nametable 1 attributes)
  LDA #$C0
  STA $2006             ; write the low byte of $27C0 address
  LDX #$40              ; fill 64 bytes
  LDA #$FF              ; palette group 3
FillAttrib1Loop:
  STA $2007
  DEX
  BNE FillAttrib1Loop
The scroll registers are at $2005. Like some other PPU registers you need to write to it twice. The first write is the horizontal scroll count, the second write is the vertical scroll count. The scroll sets which pixel of the nametable for the start of the left side of the screen. Previously we have set the scroll to 0 so the left side of the screen is aligned with the left edge of the nametable. The scroll registers are both 8 bit registers, making the scroll range 0 to 255. The screen is 256 pixels wide so the horizontal scroll register covers one full screen wide.

This sample code just increments the horizontal scroll register ($2005) by 1 on every frame. You can see when the first nametable scrolls off the screen, the second one comes on screen. The previously set colors make the split between nametables obvious. As the scroll register wraps from 255 to 0 the first nametable becomes completely visible again. You can also see the sprites are not affected by the scroll registers. They have their own separate x and y position data.
NMI:
  LDA #$00
  STA $2003       
  LDA #$02
  STA $4014       ; sprite DMA from $0200
  
  ; run other game graphics updating code here
  
  LDA #$00
  STA $2006        ; clean up PPU address registers
  STA $2006

  INC scroll       ; add one to our scroll variable each frame
  LDA scroll
  STA $2005        ; write the horizontal scroll count register

  LDA #$00         ; no vertical scrolling
  STA $2005
    
  ;;This is the PPU clean up section, so rendering the next frame starts properly.
  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  STA $2000
  LDA #%00011110   ; enable sprites, enable background, no clipping on left side
  STA $2001

  ; run normal game engine code here
  ; reading from controllers, etc
  
  RTI              ; return from interrupt

The full code and compiled .NES file is available from the download link at the bottom of this tutorial. scrolling1.asm includes everything up to this point.


Nametable Register
The problem with just the scroll register is that it isn't big enough. In the previous example the scroll wrapped from 255 to 0, so the second nametable is never shown on the left side. Both nametables together is 512 pixels wide but the scroll can only count 256 pixels. The solution is to switch which nametable is on the left side of the screen at the same time the scroll register wraps to 0.


Vertical mirroring means nametables are arranged horizontally


Scrolling shows nametable 0 and 1 (blue) on the screen (red)


When the scroll register wraps, nametable 0 is displayed again


Swap which nametable is on the left when the wrap happens to display nametable 1


To set the starting nametable, change bit 0 of the PPU control register at $2000. Clearing it to 0 will put nametables 0 and 2 on the left side of the screen with 1 and 3 to the right. Setting it to 1 will put 1 and 3 on the left, and 0 and 2 on the right.

This sample code has the same scroll incrementing, but swaps the nametables at the same time the scroll wraps from 255 to 0. Instead of the background jumping it continuously scrolls from one nametable to the next. When the scroll wraps again the nametables are swapped again and the scrolling keeps going.
NMI:

  INC scroll       ; add one to our scroll variable each frame
NTSwapCheck:
  LDA scroll       ; check if the scroll just wrapped from 255 to 0
  BNE NTSwapCheckDone
  
NTSwap:
  LDA nametable    ; load current nametable number (0 or 1)
  EOR #$01         ; exclusive OR of bit 0 will flip that bit
  STA nametable    ; so if nametable was 0, now 1
                   ;    if nametable was 1, now 0
NTSwapCheckDone:

  LDA #$00
  STA $2003       
  LDA #$02
  STA $4014       ; sprite DMA from $0200
  
  ; run other game graphics updating code here

  LDA #$00
  STA $2006        ; clean up PPU address registers
  STA $2006
  
  LDA scroll
  STA $2005        ; write the horizontal scroll count register

  LDA #$00         ; no vertical scrolling
  STA $2005
    
  ;;This is the PPU clean up section, so rendering the next frame starts properly.
  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  ORA nametable    ; select correct nametable for bit 0
  STA $2000
  
  LDA #%00011110   ; enable sprites, enable background, no clipping on left side
  STA $2001
    
  ; run normal game engine code here
  ; reading from controllers, etc
  
  RTI              ; return from interrupt

The full code and compiled .NES file is available from the download link at the bottom of this tutorial. scrolling2.asm includes everything up to this point.


Drawing New Columns
For just two screens of graphics the code above is fine. Games like Super Dodgeball use this method. Both nametables are filled and scrolled between. For games like SMB where the levels are wider than two screens some new background data will have to be inserted. The solution is to draw a new vertical column of tiles somewhere off the visible screen, before it is scrolled into the visible area. As long as the new column is drawn ahead of the visible area, calculated by the current scroll and nametable, it will appear continuous. The tricky part is figuring out which column to draw, and where it is to be placed. If we always use the opposite nametable and the same scroll point we will be drawing the column that is about to come on screen.




>When to Draw
We will draw a new column anytime the scroll register becomes a multiple of 8, meaning the scroll is aligned to the tiles. Some bit masking and testing can calculate when this happens. First any part of the scroll not 0 to 7 is thrown away. Then if the result equals 0 the scroll count is a multiple of 8.
  LDA scroll
  AND #%00000111     ; throw away higher bits
  BEQ DrawNewColumn  ; see if lower bits = 0

Where to Draw
Now that we know when to draw, we need to calculate the starting PPU address of the new column. The scroll register counts in pixels, but we want to count in tiles for which column to draw. Each tile is 8 pixels wide, so we divide the scroll by 8 to get the tile number. That number is the low bits of the address.


  LDA scroll
  LSR A
  LSR A
  LSR A            ; shift right 3 times = divide by 8
  STA columnLow    ; $00 to $1F, screen is 32 tiles wide
The high bits of the address will come from the current nametable. First the low bit is inverted, to get the off screen nametable number. Then the number is shifted up and added to the base address.
  LDA nametable
  EOR #$01          ; invert low bit, A = $00 or $01
  ASL A             ; shift up, A = $00 or $02
  ASL A             ; $00 or $04
  CLC
  ADC #$20          ; add high byte of nametable base address ($2000)
  STA columnHigh    ; now address = $20 or $24 for nametable 0 or 1
Now the scroll count and nametable have been used to make the full column address to start copying new background data. It will be at the top of the nametable that is off screen. As the scroll and nametable are changed, that calculation will still give the correct starting address.

How to Draw
Previously when we have been copying data to the background the PPU is set to auto increment the address by 1. That helps with the copying because a whole row of data can be copied while only writing the PPU address once. Incrementing by 1 goes to the next horizontal tile. In this case we want to go to the next vertical tile because we are copying a column instead of a row. We want it to increment by 32 which will jump down instead of across. There are 32 tiles per row, so adding 32 will always go down to the next row in the same column. The PPU has an increment 32 mode, set using bit 2 in the PPU control register at $2000. When bit 2 is set to 0 the increment mode is +1. When bit 2 is set to 1 the increment mode is +32. By setting the increment mode to +32 and copying 30 bytes of background tiles we can draw one column at a time.
DrawColumn:
  LDA #%00000100        ; set to increment +32 mode, don't care about other bits
  STA $2000
  
  LDA $2002             ; read PPU status to reset the high/low latch
  LDA columnHigh
  STA $2006             ; write the high byte of column address
  LDA columnLow
  STA $2006             ; write the low byte of column address
  LDX #$1E              ; copy 30 bytes
  LDY #$00
DrawColumnLoop:
  LDA columnData, y
  STA $2007
  INY
  DEX
  BNE DrawColumnLoop

By using the when/where/how we can draw a new column of data off screen before it becomes visible. The full code and compiled .NES file is available from the download link at the bottom of this tutorial. scrolling3.asm includes everything up to this point. It will be best to watch in an emulator where you can see everything that is off screen. First open the scrolling3.nes file in the FCEUXDSP emulator. Then choose "Name Table Viewer..." from the "Tools" menu. Reset the emulator and watch the new columns being drawn off the visible screen area.


Drawing Real Background Data
The last example drew new columns, but it wasn't any real data. This example adds another counter to keep track of how far along into the level a player is. By incrementing this counter every time a new column is drawn the correct next column is easy to find. The DrawNewColumn function has been updated to use the counter to load real background data. It can also be used at the beginning of the game initialization to populate the starting nametable data instead of using the fill loops.

The full code and compiled .NES file is available from the download link at the bottom of this tutorial. scrolling4.asm includes 4 screens (128 columns) of real background ripped from SMB.


Updating the Attributes
The final piece of the scrolling puzzle is the attribute table. Updating it is the same process as the background, where the attributes are updated while they are off screen. Again the scroll and nametable registers will be used to calculate the correct attribute bytes to update. Each attribute byte covers a 4x4 tile area. 4 tiles wide is 32 pixels, so the attributes must be updated anytime the scroll register is a multiple of 32. The column numbers already calculated could be used instead of the scroll variables to do the calculations.
  LDA scroll
  AND #%00011111     ; check for multiple of 32
  BEQ NewAttrib      ; if low 5 bits = 0, time to write new attribute bytes
Only 8 attribute bytes will need to be changed each time. However they are not sequential, so the PPU increment +1 or +32 modes will not work. The PPU address needs to be changed for every attribute byte updated. The starting address is the base attribute table at $20C0. Like the background address the nametable bit is shifted up and added in. Then the scroll register is divided by 32 to get the attribute byte offset. All that is calculated together to find the PPU address of the first attribute byte. After that 8 is added to the address for each of the next bytes.
  LDA nametable
  EOR #$01          ; invert low bit, A = $00 or $01
  ASL A             ; shift up, A = $00 or $02
  ASL A             ; $00 or $04
  CLC
  ADC #$20          ; add high byte of attribute base address ($20C0)
  STA columnHigh    ; now address = $20 or $24 for nametable 0 or 1
  
  LDA scroll
  LSR A
  LSR A
  LSR A
  LSR A
  LSR A
  CLC
  ADC #$C0
  STA columnLow     ; attribute base + scroll / 32
The full code and compiled .NES file is available from the download link at the bottom of this tutorial. scrolling5.asm has the same incrementing scroll, but now draws the new column and attribute bytes. Use the Name Table Viewer again to check out the attributes being updated. You can see the attribute update change the color of the off screen clouds before that column of tiles is changed. The same thing is why you see graphical glitches on the sides of SMB3 while it is scrolling. To use this in your own game you will need to expand columnNumber to a bigger value.



Once you have understood everything here, there are some more advanced concepts to check out:

Meta Tiles - This idea is to store your backgrounds as bigger blocks instead of individual tiles. Things like the question blocks would be stored as one byte in the ROM and then decoded into the 4 tiles when it is being drawn. Mostly this saves huge amounts of data space and could make updating attributes easier.

Buffers - A section of RAM can be reserved to act as a buffer for the data to draw to the PPU later. Outside of vblank where the is more processing time the next graphics updates would be calculated and stored in a buffer. Then during vblank those buffers can be dumped right to the PPU, saving time.

Compression - Packing the background data into simple compression formats like RLE can save even more data space. Combine that with meta tiles and buffers to have a full scrolling engine.

Putting It All Together
Download and unzip the scrolling.zip sample files. Each of them adds a small step, so go through them one at a time. Try expanding the background data to add more columns, making the scroll speed variable, or making the scrolling controlable.
Back to Table of Contents Toggle CommentsOriginal Article
Advanced Nerdy Nights #4: Sprite 0 hit for a status bar
This Week: After scrolling this tutorial should be pretty simple. Sprite 0 has a special PPU flag associated with it. Here it will be used to do split screen scrolling to enable a static status bar on the top of the screen.



Sprite 0 Hit Flag
Sprite 0 has a special flag in the PPU status register at bit 6. When a non transparent pixel of sprite 0 overlaps a non transparent pixel of the background, the flag is set. In the SMB example, sprite 0 is placed at the bottom of the coin icon. That is one part of the status bar that does not move.

 

In our example we first set the scroll registers to 0 for the static status bar. The nametable is also set to 0. That makes sure that the background and sprite 0 will overlap in the correct place.


NMI:

  ; all graphics updating code goes here

  LDA #$00
  STA $2006        ; clean up PPU address registers
  STA $2006
  
  LDA #$00         ; start with no scroll for status bar
  STA $2005
  STA $2005
  
  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  STA $2000        ; start with nametable = 0 for status bar

  LDA #%00011110   ; enable sprites, enable background, no clipping on left side
  STA $2001
Next we make sure the sprite 0 hit flag is clear, to avoid it being tripped from the previous frame. The flag is cleared at the end of vblank, so once it equals 0 you know the next frame has started.


WaitNotSprite0:
  lda $2002
  and #%01000000
  bne WaitNotSprite0   ; wait until sprite 0 not hit

Now we wait until the sprite 0 is hit. How long this takes depends on how far down the screen your sprite 0 is placed.


WaitSprite0:
  lda $2002
  and #%01000000
  beq WaitSprite0      ; wait until sprite 0 is hit

When that loop finishes, the PPU is drawing the first pixels of sprite 0 that overlap pixels on the background. We add a small wait loop so the rest of the status bar is drawn, and then change the scroll registers. The rest of the screen down is drawn using those settings.


  ldx #$10
WaitScanline:
  dex
  bne WaitScanline
  
  LDA scroll
  STA $2005        ; write the horizontal scroll count register
  LDA #$00         ; no vertical scrolling
  STA $2005
    
  LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  ORA nametable    ; select correct nametable for bit 0
  STA $2000

So the order is:
  1 - set scroll to 0 for status bar
  2 - wait for sprite 0 hit = 0
  3 - wait for sprite 0 hit = 1
  4 - delay so scanline finishes drawing
  5 - set scroll for level background

The only other change is to make sure your graphics updating code does not draw over the status bar. The previous DrawNewColumn function handles the graphics updates so it has a few small differences. The starting address is increased by $80 to skip the first 4 rows of background. Then the source address is increased by $04 for the same reason.



Putting It All Together
Download and unzip the sprite0.zip sample files. sprite0.asm is the same as the previous scrolling5.asm file plus the changes covered here. This is another good one to watch in an emulator.


PPU scrolling
Jump to navigationJump to search
Scrolling is the movement of the displayed portion of the map. Games scroll to show an area much larger than the 256x240 pixel screen. For example, areas in Super Mario Bros. are many screens wide. The NES's first major improvement over its immediate predecessors (ColecoVision and Sega SG-1000) was pixel-level scrolling of playfields.


Contents
1	The common case
1.1	Frequent pitfalls
2	PPU internal registers
3	Register controls
3.1	$2000 (PPUCTRL) write
3.2	$2002 (PPUSTATUS) read
3.3	$2005 (PPUSCROLL) first write (w is 0)
3.4	$2005 (PPUSCROLL) second write (w is 1)
3.5	$2006 (PPUADDR) first write (w is 0)
3.6	$2006 (PPUADDR) second write (w is 1)
3.7	$2007 (PPUDATA) reads and writes
3.8	At dot 256 of each scanline
3.9	At dot 257 of each scanline
3.10	During dots 280 to 304 of the pre-render scanline (end of vblank)
3.11	Between dot 328 of a scanline, and 256 of the next scanline
3.12	Explanation
3.13	Summary
4	Wrapping around
4.1	Coarse X increment
4.2	Y increment
4.3	Tile and attribute fetching
5	Examples
5.1	Single scroll
5.2	Split X scroll
5.3	Split X/Y scroll
5.3.1	Details
5.4	Quick coarse X/Y split
6	See Also
7	References
The common case
Ordinarily, a program writes to two PPU registers to set the scroll position in its NMI handler:

Find the 9-bit X and Y coordinates of the upper left corner of the visible area (the part seen by the "camera")
Write the lower 8 bits of the X coordinate to PPUSCROLL ($2005)
Write the lower 8 bits of the Y coordinate to PPUSCROLL
Write the 9th bit of X and Y to bits 0 and 1, respectively, of PPUCTRL ($2000)
This is the nametable that's visible in the top-left corner
The scroll position written to PPUSCROLL is applied at the end of vertical blanking, just before rendering begins, therefore these writes need to occur before the end of vblank. Also, because writes to PPUADDR ($2006) can overwrite the scroll position, the two writes to PPUSCROLL and the write to PPUCTRL must be done after any updates to VRAM using PPUADDR.

By itself, this allows moving the camera within a usually two-screen area (see Mirroring), with horizontal and vertical wraparound if the camera goes out of bounds. To scroll over a larger area than the two screens that are already in VRAM, you choose appropriate offscreen columns or rows of the nametable, and you write that to VRAM before you set the scroll, as seen in the animation below. The area that needs rewritten at any given time is sometimes called the "seam" of the scroll.

NTS scrolling seam.gif
Frequent pitfalls
Don't take too long
If your NMI handler routine takes too long and PPUSCROLL ($2005) is not set before the end of vblank, the scroll will not be correctly applied this frame. Most games do not write more than 64 bytes to the nametable per NMI; more than this may require advanced techniques to fit this narrow window of time.
Set the scroll last
After using PPUADDR ($2006), the program must always set PPUCTRL and PPUSCROLL again. They have a shared internal register and using PPUADDR will overwrite the scroll position.
PPU internal registers
If the screen does not use split-scrolling, setting the position of the background requires only writing the X and Y coordinates to $2005 and the high bit of both coordinates to $2000.

Programming or emulating a game that uses complex raster effects, on the other hand, requires a complete understanding of how the various address registers inside the PPU work.

Here are the related registers:

v
Current VRAM address (15 bits)
t
Temporary VRAM address (15 bits); can also be thought of as the address of the top left onscreen tile.
x
Fine X scroll (3 bits)
w
First or second write toggle (1 bit)
The PPU uses the current VRAM address for both reading and writing PPU memory thru $2007, and for fetching nametable data to draw the background. As it's drawing the background, it updates the address to point to the nametable data currently being drawn. Bits 10-11 hold the base address of the nametable minus $2000. Bits 12-14 are the Y offset of a scanline within a tile.

The 15 bit registers t and v are composed this way during rendering:

yyy NN YYYYY XXXXX
||| || ||||| +++++-- coarse X scroll
||| || +++++-------- coarse Y scroll
||| ++-------------- nametable select
+++----------------- fine Y scroll
Note that while the v register has 15 bits, the PPU memory space is only 14 bits wide. The highest bit is unused for access through $2007.

Register controls
In the following, d refers to the data written to the port, and A through H to individual bits of a value.

$2005 and $2006 share a common write toggle w, so that the first write has one behaviour, and the second write has another. After the second write, the toggle is reset to the first write behaviour. This toggle may be manually reset by reading $2002.

$2000 (PPUCTRL) write
t: ...GH.. ........ <- d: ......GH
   <used elsewhere> <- d: ABCDEF..
$2002 (PPUSTATUS) read
w:                  <- 0
$2005 (PPUSCROLL) first write (w is 0)
t: ....... ...ABCDE <- d: ABCDE...
x:              FGH <- d: .....FGH
w:                  <- 1
Note that w is shared between $2005 and $2006. For a worked example of interleaving writes to both, see § Details

$2005 (PPUSCROLL) second write (w is 1)
t: FGH..AB CDE..... <- d: ABCDEFGH
w:                  <- 0
$2006 (PPUADDR) first write (w is 0)
t: .CDEFGH ........ <- d: ..CDEFGH
       <unused>     <- d: AB......
t: Z...... ........ <- 0 (bit Z is cleared)
w:                  <- 1
$2006 (PPUADDR) second write (w is 1)
t: ....... ABCDEFGH <- d: ABCDEFGH
v: <...all bits...> <- t: <...all bits...>
w:                  <- 0
$2007 (PPUDATA) reads and writes
Outside of rendering, reads from or writes to $2007 will add either 1 or 32 to v depending on the VRAM increment bit set via $2000. During rendering (on the pre-render line and the visible lines 0-239, provided either background or sprite rendering is enabled), it will update v in an odd way, triggering a coarse X increment and a Y increment simultaneously (with normal wrapping behavior). Internally, this is caused by the carry inputs to various sections of v being set up for rendering, and the $2007 access triggering a "load next value" signal for all of v (when not rendering, the carry inputs are set up to linearly increment v by either 1 or 32). This behavior is not affected by the status of the increment bit. The Young Indiana Jones Chronicles uses this for some effects to adjust the Y scroll during rendering, and also Burai Fighter (U) to draw the scorebar. If the $2007 access happens to coincide with a standard VRAM address increment (either horizontal or vertical), it will presumably not double-increment the relevant counter.

At dot 256 of each scanline
If rendering is enabled, the PPU increments the vertical position in v. The effective Y scroll coordinate is incremented, which is a complex operation that will correctly skip the attribute table memory regions, and wrap to the next nametable appropriately. See Wrapping around below.

At dot 257 of each scanline
If rendering is enabled, the PPU copies all bits related to horizontal position from t to v:

v: ....A.. ...BCDEF <- t: ....A.. ...BCDEF
During dots 280 to 304 of the pre-render scanline (end of vblank)
If rendering is enabled, at the end of vblank, shortly after the horizontal bits are copied from t to v at dot 257, the PPU will repeatedly copy the vertical bits from t to v from dots 280 to 304, completing the full initialization of v from t:

v: GHIA.BC DEF..... <- t: GHIA.BC DEF.....
Between dot 328 of a scanline, and 256 of the next scanline
If rendering is enabled, the PPU increments the horizontal position in v many times across the scanline, it begins at dots 328 and 336, and will continue through the next scanline at 8, 16, 24... 240, 248, 256 (every 8 dots across the scanline until 256). Across the scanline the effective coarse X scroll coordinate is incremented repeatedly, which will also wrap to the next nametable appropriately. See Wrapping around below.

Explanation
The implementation of scrolling has two components. There are two fine offsets, specifying what part of an 8x8 tile each pixel falls on, and two coarse offsets, specifying which tile. Because each tile corresponds to a single byte addressable by the PPU, during rendering the coarse offsets reuse the same VRAM address register (v) that is normally used to send and receive data from the PPU. Because of this reuse, the two registers $2005 and $2006 both offer control over v, but $2005 is mapped in a more obscure way, designed specifically to be convenient for scrolling.
$2006 is simply to set the VRAM address register. This is why the second write will immediately set v; it is expected you will immediately use this address to send data to the PPU via $2007. The PPU memory space is only 14 bits wide, but v has an extra bit that is used for scrolling only. The first write to $2006 will clear this extra bit (for reasons not known).
$2005 is designed to set the scroll position before the start of the frame. This is why it does not immediately set v, so that it can be set at precisely the right time to start rendering the screen.
The high 5 bits of the X and Y scroll settings sent to $2005, when combined with the 2 nametable select bits sent to $2000, make a 12 bit address for the next tile to be fetched within the nametable address space $2000-2FFF. If set before the end of vblank, this 12 bit address gets loaded directly into v precisely when it is needed to fetch the tile for the top left pixel to render.
The low 3 bits of X sent to $2005 (first write) control the fine pixel offset within the 8x8 tile. The low 3 bits goes into the separate x register, which just selects one of 8 pixels coming out of a set of shift registers. This fine X value does not change during rendering; the only thing that changes it is a $2005 first write.
The low 3 bits of Y sent to $2005 (second write) control the vertical pixel offset within the 8x8 tile. The low 3 bits goes into the high 3 bits of the v register, where during rendering they are not used as part of the PPU memory address (which is being overridden to use the nametable space $2000-2FFF). Instead they count the lines until the coarse Y memory address needs to be incremented (and wrapped appropriately when nametable boundaries are crossed).
See also: PPU Frame timing

Summary
The following diagram illustrates how several different actions may update the various internal registers related to scrolling. See Examples below for usage examples.

Action	Before	Instructions	After	Notes
t	v	x	w	t	v	x	w
(PPUCTRL)
$2000 write

....... ........	....... ........	...	.	LDA #$00 (%00000000)
STA $2000	...00.. ........	....... ........	...	.	
(PPUSTATUS)
$2002 read

...00.. ........	....... ........	...	.	LDA $2002	...00.. ........	....... ........	...	0	Resets paired write latch w to 0.
(PPUSCROLL)
$2005 write 1

...00.. ........	....... ........	...	0	LDA #$7D (%01111101)
STA $2005	...00.. ...01111	....... ........	101	1	
(PPUSCROLL)
$2005 write 2

...00.. ...01111	....... ........	101	1	LDA #$5E (%01011110)
STA $2005	1100001 01101111	....... ........	101	0	
(PPUADDR)
$2006 write 1

1100001 01101111	....... ........	101	0	LDA #$3D (%00111101)
STA $2006	0111101 01101111	....... ........	101	1	Bit 14 (15th bit) of t gets set to zero
(PPUADDR)
$2006 write 2

0111101 01101111	....... ........	101	1	LDA #$F0 (%11110000)
STA $2006	0111101 11110000	0111101 11110000	101	0	After t is updated, contents of t copied into v
Wrapping around
The following pseudocode examples explain how wrapping is performed when incrementing components of v. This code is written for clarity, and is not optimized for speed.

Coarse X increment
The coarse X component of v needs to be incremented when the next tile is reached. Bits 0-4 are incremented, with overflow toggling bit 10. This means that bits 0-4 count from 0 to 31 across a single nametable, and bit 10 selects the current nametable horizontally.

if ((v & 0x001F) == 31) // if coarse X == 31
  v &= ~0x001F          // coarse X = 0
  v ^= 0x0400           // switch horizontal nametable
else
  v += 1                // increment coarse X
Y increment
If rendering is enabled, fine Y is incremented at dot 256 of each scanline, overflowing to coarse Y, and finally adjusted to wrap among the nametables vertically.

Bits 12-14 are fine Y. Bits 5-9 are coarse Y. Bit 11 selects the vertical nametable.

if ((v & 0x7000) != 0x7000)        // if fine Y < 7
  v += 0x1000                      // increment fine Y
else
  v &= ~0x7000                     // fine Y = 0
  int y = (v & 0x03E0) >> 5        // let y = coarse Y
  if (y == 29)
    y = 0                          // coarse Y = 0
    v ^= 0x0800                    // switch vertical nametable
  else if (y == 31)
    y = 0                          // coarse Y = 0, nametable not switched
  else
    y += 1                         // increment coarse Y
  v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v
Row 29 is the last row of tiles in a nametable. To wrap to the next nametable when incrementing coarse Y from 29, the vertical nametable is switched by toggling bit 11, and coarse Y wraps to row 0.

Coarse Y can be set out of bounds (> 29), which will cause the PPU to read the attribute data stored there as tile data. If coarse Y is incremented from 31, it will wrap to 0, but the nametable will not switch. For this reason, a write >= 240 to $2005 may appear as a "negative" scroll value, where 1 or 2 rows of attribute data will appear before the nametable's tile data is reached. (Some games use this to move the top of the nametable out of the Overscan area.)

Tile and attribute fetching
The high bits of v are used for fine Y during rendering, and addressing nametable data only requires 12 bits, with the high 2 CHR address lines fixed to the 0x2000 region. The address to be fetched during rendering can be deduced from v in the following way:

 tile address      = 0x2000 | (v & 0x0FFF)
 attribute address = 0x23C0 | (v & 0x0C00) | ((v >> 4) & 0x38) | ((v >> 2) & 0x07)
The low 12 bits of the attribute address are composed in the following way:

 NN 1111 YYY XXX
 || |||| ||| +++-- high 3 bits of coarse X (x/4)
 || |||| +++------ high 3 bits of coarse Y (y/4)
 || ++++---------- attribute offset (960 bytes)
 ++--------------- nametable select
Examples
Single scroll
If only one scroll setting is needed for the entire screen, this can be done by writing $2000 once, and $2005 twice before the end of vblank.

The low two bits of $2000 select which of the four nametables to use.
The first write to $2005 specifies the X scroll, in pixels.
The second write to $2005 specifies the Y scroll, in pixels.
This should be done after writes to $2006 are completed, because they overwrite the t register. The v register will be completely copied from t at the end of vblank, setting the scroll.

Note that the series of two writes to $2005 presumes the toggle that specifies which write is taking place. If the state of the toggle is unknown, reset it by reading from $2002 before the first write to $2005.

Instead of writing $2000, the first write to $2006 can be used to select the nametable, if this happens to be more convenient (usually it is not because it will toggle w).

Split X scroll
The X scroll can be changed at the end of any scanline when the horizontal components of v get reloaded from t: Simply make writes to $2000/$2005 before the end of the line.

The first write to $2005 alters the horizontal scroll position. The fine x register (sub-tile offset) gets updated immediately, but the coarse horizontal component of t (tile offset) does not get updated until the end of the line.
An optional second write to $2005 is inconsequential; the changes it makes to t will be ignored at the end of the line. However, it will reset the write toggle w for any subsequent splits.
Write to $2000 if needed to set the high bit of X scroll, which is controlled by bit 0 of the value written. Writing $2000 changes other rendering properties as well, so make sure the other bits are set appropriately.
Like the single scroll example, reset the toggle by reading $2002 if it is in an unknown state. Since a write to $2005 and a read from $2002 are equally expensive in both bytes and time, whether you use one or the other to prepare for subsequent screen splits is up to you.

The first write to $2005 should usually be made as close to the end of the line as possible, but before the start of hblank when the coarse x scroll is copied from t to v. Because about 4 pixels of timing jitter are normally unavoidable, $2005 should be written a little bit early (once hblank begins, it is too late). The resulting glitch at the end of the line can be concealed by a line of one colour pixels or a sprite.

It is also possible to completely hide this glitch by first writing a combination of the new coarse X and old fine X to a mirror of $2005 before dot 257, then writing the entire new X to $2005 between dot 257 and the end of the scanline. On certain alignments, the PPU will use the contents of open bus to set fine X for one pixel. Thus the correct mirror to use is one where the lowest 3 bits of its upper byte matches the lowest 3 bits of the value you're writing. e.g. Write %xxxxx000 to $2005, write %xxxxx001 to $2105, etc.

The code may look like this:

  lda new_x  ; Combine bits 7-3 of new X with 2-0 of old X
  eor old_x
  and #%11111000
  eor old_x
  sta $2005  ; Write old fine X and new coarse X
  bit $2002  ; Clear first/second write toggle
  lda new_x  
  sta old_x
  nop        ; Wait for the next write to land in hblank
  nop
  sta $2005  ; Write entire new X
  bit $2002  ; Clear first/second write toggle
For more flexible control, the following more advanced X/Y scroll technique could be used to update v during hblank instead.

Split X/Y scroll
Cleanly setting the complete scroll position (X and Y) mid-screen takes four writes:

Nametable number << 2 (that is: $00, $04, $08, or $0C) to $2006
Y to $2005
X to $2005
Low byte of nametable address to $2006, which is ((Y & $F8) << 2) | (X >> 3)
The last two writes should occur during horizontal blanking (cycle 256 or later) to avoid visual errors. (Because of right overscan and the background pixel pipeline, it may be acceptable to land the third write as early as cycle 252.)

The code may look like this:

; The first two PPU writes can come anytime during the scanline:
; Nametable number << 2 to $2006.
lda new_nametable_x
lsr
lda new_nametable_y
rol
asl
asl
sta $2006

; Y position to $2005.
lda new_y
sta $2005

; Prepare for the 2 later writes:
; We reuse new_x to hold (Y & $F8) << 2.
and #%11111000
asl
asl
ldx new_x  ; X position in X for $2005 later.
sta new_x

; ((Y & $F8) << 2) | (X >> 3) in A for $2006 later.
txa
lsr
lsr
lsr
ora new_x

; Burn cycles until start of hblank
; (Adjust for your application)
nop
nop

; The last two PPU writes must happen during hblank:
stx $2005
sta $2006

; Restore new_x.
stx new_x
Details
To split both the X and Y scroll on a scanline, we must perform four writes to $2006 and $2005 alternately in order to completely reload v. Without the second write to $2006, only the horizontal portion of v will loaded from t at the end of the scanline. By writing twice to $2006, the second write causes an immediate full reload of v from t, allowing you to update the vertical scroll in the middle of the screen. Because of the background pattern FIFO, the visible effect of a mid-scanline write is delayed by 1 to 2 tiles.

The writes to PPU registers are done in the order of $2006, $2005, $2005, $2006. This order of writes is important, understanding that the write toggle for $2005 is shared with $2006. As always, if the state of the toggle is unknown before beginning, read $2002 to reset it.

In this example we will perform two writes to each of $2005 and $2006. We will set the X scroll (X), Y scroll (Y), and nametable select (N) by writes to $2005 and $2006. Repeating the above summaries:

N: %01
X: %01111101 = $7D
Y: %00111110 = $3E
$2005 (w=0) = X                                                          = %01111101 = $7D
$2005 (w=1) = Y                                                          = %00111110 = $3E
$2006 (w=0) = ((Y & %11000000) >> 6) | ((Y & %00000011) << 4) | (N << 2) = %00010100 = $14
$2006 (w=1) = ((X & %11111000) >> 3) | ((Y & %00111000) << 2)            = %11101111 = $EF
However, since there is a great deal of overlap between the data sent to $2005 and $2006, only the last write to any particular bit of t matters. This makes the first write to $2006 mostly redundant, and we can simplify its setup significantly:

$2006 (w=0) = N << 2                                                     = %00000100 = $04
There are other redundancies in the writes to $2005, but since it is likely the original X and Y values are already available, these can be left as an exercise for the reader.

Before	Instructions	After	Notes
t	v	x	w	t	v	x	w
....... ........	....... ........	...	0	LDA #$04 (%00000100)
STA $2006	0000100 ........	....... ........	...	1	Bit 14 of t set to zero
0000100 ........	....... ........	...	1	LDA #$3E (%00111110)
STA $2005	1100100 111.....	....... ........	...	0	Behaviour of 2nd $2005 write
1100100 111.....	....... ........	...	0	LDA #$7D (%01111101)
STA $2005	1100100 11101111	....... ........	101	1	Behaviour of 1st $2005 write
1100100 11101111	....... ........	101	1	LDA #$EF (%11101111)
STA $2006	1100100 11101111	1100100 11101111	101	0	After t is updated, contents of t copied into v
Timing for this series of writes is important. Because the Y scroll in v will be incremented at dot 256, you must either set it to the intended Y-1 before dot 256, or set it to Y after dot 256. Many games that use split scrolling have a visible glitch at the end of the line by timing it early like this.

Alternatively you can set the intended Y after dot 256. The last two writes ($2005 (w=0) / $2006 (w=1)) can be timed to fall within hblank to avoid any visible glitch. Hblank begins after dot 256, and ends at dot 320 when the first tile of the next line is fetched.

Because this method sets v immediately, it can be used to set the scroll in the middle of the line. This is not normally recommended, as the difficulty of exact timing and interaction of tile fetches makes it difficult to do cleanly.

Quick coarse X/Y split
Since it is the write to $2006 when w=1 that transfers the contents of t to v, it is not strictly necessary to perform all 4 writes as above, so long as one is willing to accept some trade-offs.

For example, if you only write to $2006 twice, you can update coarse X, coarse Y, N, and the bottom 2 bits of fine y. The top bit of fine y is cleared, and fine x is unchanged.

$2006's contents are in the same order as t, so you can affect the bits as:

   First      Second
/¯¯¯¯¯¯¯¯¯\ /¯¯¯¯¯¯¯\
0 0yy NN YY YYY XXXXX
  ||| || || ||| +++++-- coarse X scroll
  ||| || ++-+++-------- coarse Y scroll
  ||| ++--------------- nametable select
  +++------------------ fine Y scroll




Let me explain how CHR banking works on the NES:
The NES PPU (Picture Processing Unit) has two pattern tables, each 4KB in size:
Pattern Table 0: $0000-$0FFF (first 4KB)
Pattern Table 1: $1000-$1FFF (second 4KB)
Each 8x8 tile takes up 16 bytes, so:
A 128x128 section contains 256 tiles (16x16 tiles)
Each pattern table can hold 256 tiles (4KB ÷ 16 bytes per tile)
A full 128x256 sprite sheet contains 512 tiles
When you use bank_bg() and bank_spr():
bank_bg(0) uses Pattern Table 0 for background tiles
bank_bg(1) uses Pattern Table 1 for background tiles
bank_spr(0) uses Pattern Table 0 for sprite tiles
bank_spr(1) uses Pattern Table 1 for sprite tiles
So in your case:
Your first CHR file (ninjaturdle.chr) contains both pattern tables (8KB total):
First 4KB (bank 0) = top 128x128 of your sprite sheet
Second 4KB (bank 1) = bottom 128x128 of your sprite sheet